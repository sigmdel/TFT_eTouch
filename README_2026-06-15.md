File: README_2026-06-15.md

## Added Configuration Options

### Purpose

This [fork](https://github.com/sigmdel/TFT_eTouch) of [TFT_eTouch](https://github.com/achillhasler/TFT_eTouch) adds options in the [user configuration file](TFT_eTouchUser.h) to simplify the use of displays that have a touch controller and a display driver that are connected to different SPI peripherals.

### Some Background

Following a [suggestion](https://github.com/Bodmer/TFT_eSPI/issues/287#issuecomment-455572468) by bodmer (author of [TFT_eSPI](https://github.com/Bodmer/TFT_eSPI)), TFT_eTouch was created by Achill Hasler about four years ago (2019) as a replacement for the touch handler code in TFT_eSPI.  However, as of now, the built-in touch handler remains in place.

### On Using TFT_eTouch

To use TFT_eTouch instead of the built-in touch driver found in TFT_eSPI,

  1. **ensure that `TOUCH_CS` is NOT defined in the TFT_eSPI user configuration file** `User_Setup.h`. 

  1. **do not set** `Compiler warnings` **at levels above** `Default`.

>If using TFT_eTouch and if `Compiler warnings` are set to `More` or `All` in the Arduino IDE `Preference`, a sketch will not compile. This is because TFT_eTouchGesture will generate warnings of the type `variable 'xneg' set but not used` which are treated as errors. 



### Support for Touch Controllers Connected to a Second SPI Peripheral

The default touch code in TFT_eSPI assumes that the touch controller and the display driver are both connected to the same SPI peripheral. That is not always the case. TFT_eTouch can handle a touch controller that is connected to the same SPI peripheral as the display driver or to a different peripheral. In the latter case, define `SECOND_SPI_PORT` at the top of [TFT_eTouchUser.h](TFT_eTouchUser.h).

```cpp
/**@def SECOND_SPI_PORT
 * Define if the touch controller uses separate SPI peripheral than TFT controller.
 */
#define SECOND_SPI_PORT
```

By default the following pin assignments will be made

| Identifier | ESP32 GPIO Pin Number |
| --- | :---: |
| TFT_ETOUCH_CS | 33 |
| TFT_ETOUCH_PIRQ | 255  |
| TFT_ETOUCH_SCK | 14 |
| TFT_ETOUCH_MISO | 12 |
| TFT_ETOUCH_MOSI | 13 |

Adjust these in the file if necessary. 

### Support for the ESP32_2432S028 Dev Board 

This board ( aka [cheap yellow display](https://github.com/witnessmenow/ESP32-Cheap-Yellow-Display)), uses an XPT2046 touch controller connected to SPI peripheral different from the one used for the ILI9341 TFT driver chip. When using this board
define `ESP32_2432S028R` at the top of [TFT_eTouchUser.h](TFT_eTouchUser.h).


 ```cpp
 /** @def ESP32_2432S028R
 * Define if an ESP32-2432S028R dev board (a.k.a "cheap yellow display") is being used.
 * Non default pins are used with its second SPI peripheral connected to the touch controller
 */
#define ESP32_2432S028R
```

This will in turn define `SECOND_SPI_PORT` but the pin assignment will be different:


| Identifier | ESP32 GPIO Pin Number |
| --- | :---: |
| TFT_ETOUCH_CS | 3 |
| TFT_ETOUCH_PIRQ | 36  |
| TFT_ETOUCH_SCK | 25 |
| TFT_ETOUCH_MISO | 39 |
| TFT_ETOUCH_MOSI | 32 |

It should not be necessary to adjust these values.

### Setup and Using TFT_eTouch

Here is a typical setup and usage of the TFT_eTouch library.

```cpp
#include <FS.h>
#include <SPI.h>
#include <TFT_eSPI.h> // Hardware-specific library
#include <TFT_eTouch.h>

TFT_eSPI tft;         // Invoke custom library

#ifdef SECOND_SPI_PORT
  SPIClass hSPI(HSPI);
  TFT_eTouch<TFT_eSPI> touch(tft, TFT_ETOUCH_CS, TFT_ETOUCH_PIRQ, hSPI); 
#else
  TFT_eTouch<TFT_eSPI> touch(tft, TFT_ETOUCH_CS, TFT_ETOUCH_PIRQ, TFT_eSPI::getSPIinstance());
#endif

void setup(void) {
  Serial.begin(115200);
  //Set up the display
  tft.init();
  tft.setRotation(1); // landscape 

  #ifdef SECOND_SPI_PORT
    hSPI.begin(TFT_ETOUCH_SCK, TFT_ETOUCH_MISO, TFT_ETOUCH_MOSI, TFT_ETOUCH_CS);
  #endif
  touch.init();
...
}

void loop(void) {
  // Pressed will be set true is there is a valid touch on the screen
  int16_t t_x = 0, t_y = 0; // To store the touch coordinates
  bool pressed = touch.getXY(t_x, t_y);
... 
}
```

However, with conditional defines, it is possible to write code that could be used with the touch code handler built-in to TFT_eSPI or with the TFT_eTouch library.

```cpp
#include <FS.h>
#include <SPI.h>
#include <TFT_eSPI.h> // Hardware-specific library
#ifndef TOUCH_CS
#include <TFT_eTouch.h>
#endif

TFT_eSPI tft;         // Invoke custom library

#ifndef TOUCH_CS      // Invoke TFT_eTouch 
  #ifdef SECOND_SPI_PORT
    SPIClass hSPI(HSPI);
    TFT_eTouch<TFT_eSPI> touch(tft, TFT_ETOUCH_CS, TFT_ETOUCH_PIRQ, hSPI); 
  #else
    TFT_eTouch<TFT_eSPI> touch(tft, TFT_ETOUCH_CS, TFT_ETOUCH_PIRQ, TFT_eSPI::getSPIinstance());
  #endif
#endif

void setup(void) {
  Serial.begin(115200);
  //Set up the display
  tft.init();
  tft.setRotation(1); // landscape 

  #ifndef TOUCH_CS  // Using TFT_eTouch
    #ifdef SECOND_SPI_PORT
      hSPI.begin(TFT_ETOUCH_SCK, TFT_ETOUCH_MISO, TFT_ETOUCH_MOSI, TFT_ETOUCH_CS);
    #endif
    touch.init();
  #endif
...
}

void loop(void) {
  // Pressed will be set true is there is a valid touch on the screen
  #ifdef TOUCH_CS
  uint16_t t_x = 0, t_y = 0; // To store the touch coordinates
  bool pressed = tft.getTouch(&t_x, &t_y);
  #else
  int16_t t_x = 0, t_y = 0; // To store the touch coordinates
  bool pressed = touch.getXY(t_x, t_y);
  #endif
... 
}
```
